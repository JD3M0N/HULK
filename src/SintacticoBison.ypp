%code requires {
    #include "tree.hpp"
    #include <vector>
    #include <string>
    #include "error_handler.hpp"
    
    class Statement;
    class Expression;
    class Node; 
    extern Node* root; 

    // Estructura para ElifList (vector of pairs: condition, then-expression)
    typedef std::vector<std::pair<Expression*, Expression*>> ElifListType;

    // Helper structure for if_expr's else part
    struct ElsePartInfo {
        ElifListType* elifs; // Can be nullptr if no elifs
        Expression* else_expr;   // Can be nullptr if no else
        bool has_else_keyword; // True if ELSE keyword was present

        ElsePartInfo(ElifListType* efs, Expression* ee, bool hek) : elifs(efs), else_expr(ee), has_else_keyword(hek) {}
    };
}

// Enable location tracking
%locations
%define parse.error verbose

%{
#include <cstdio>
#include <cstdlib>
#include "tree.hpp"
#include <vector>
#include <string>
#include "error_handler.hpp"

extern char* yytext;
extern int yylex();
extern int yylineno;
extern int yycolumn;

Node* root = nullptr; 


// Improved error reporting
void yyerror(const char *s) {
    SourceLocation loc(yylineno, yycolumn);
    SYNTAX_ERROR(std::string(s) + " cerca de '" + yytext + "'", loc);
}
%}

%union {
    int ival;
    double dval;
    char* sval;
    Statement* stmt;
    Expression* expr;
    std::vector<Statement*>* stmt_list;
    std::vector<std::pair<std::string, Expression*>>* binding_list_type; // For let bindings
    std::vector<Expression*>* expr_list;
    std::vector<std::string>* param_list;
    ElifListType* elif_list_type; // For non-empty elif lists
    BlockExpression* blocks; // Assuming BlockExpression* is meant, not BlockStatement
    Program* program_node; // Changed from Program* program to avoid conflict if Program is a type name
    ElsePartInfo* else_part_info_type; // For if_expr's else part
}

// Tokens
%token <dval> NUMBER
%token <sval> ID STRING
%token LET IN PRINT FUNCTION /* FOR removed, see below */
%token IF ELSE ELIF WHILE FOR // FOR is here
%token CONCAT ARROW "=>"
%token EQ NEQ LE GE AND OR
%token ASSIGN
%token '{' '}'

// Precedencias y asociatividades
// Bison reads precedence from top to bottom.
// Operators on later lines or further to the right on the same line have higher precedence.
// Therefore, operators with *lower* precedence should appear *earlier* in this list.

// Special non-associative markers for grammar constructs.
// Their placement helps resolve specific shift/reduce conflicts, often related to if-else or similar constructs.
%nonassoc LET_IN_PREC
%nonassoc IF_PREC
%nonassoc ELSE

// Assignment operator: should have low precedence and typically be right-associative.
%right ASSIGN          // Corrected: Lower precedence and right-associative

// Logical operators
%left OR
%left AND

// Comparison operators: non-associative is common to prevent chaining like a < b < c without explicit grouping.
%nonassoc EQ NEQ '<' '>' LE GE

// Concatenation operator
%left CONCAT

// Arithmetic operators:
// '+' and '-' are left-associative.
// '^' is currently left-associative and at the same precedence level as '+' and '-'.
// This is unusual for exponentiation, which is often right-associative and higher precedence than multiply/divide.
// However, sticking to the original language's apparent design for '^' for now.
%left '+' '-' '^'

// '*' '/' '%' are left-associative and have higher precedence than '+', '-', '^'.
%left '*' '/' '%'

// Tokens/keywords that might need precedence for specific parsing situations,
// e.g., to distinguish a function declaration keyword from an identifier.
%nonassoc FUNCTION_PREC // For the FUNCTION keyword in function declarations
%nonassoc ID            // For identifiers, often treated as primary expressions.
                        // Can help resolve shift/reduce if ID can be followed by operators or '('.


// Tipos de retorno
%type <stmt> statement function_declaration while_statement expression_statement
%type <expr> expression while_expr print_expr let_in_expr if_expr block_expr for_loop_expr
%type <stmt_list> statement_list function_list block_stmt_body
%type <binding_list_type> binding_list
%type <expr_list> expr_list
%type <param_list> param_list
%type <elif_list_type> elif_list_non_empty
%type <else_part_info_type> opt_else_part
// Removed %type <program_node> program; as program rule does not set $$

%%

program
    : function_list statement_list {
        std::vector<FunctionDeclaration*> funcs;
        for (auto* s : *$1) {
            if (auto* f = dynamic_cast<FunctionDeclaration*>(s)) funcs.push_back(f);
            // else delete s; // Important: handle or delete non-function statements if any
        }
        root = new Program(SourceLocation(yylineno, @1.first_column), funcs, *$2); // Assuming Program constructor takes loc
        delete $1; // $1 is stmt_list, its elements are moved or should be deleted
        // $2 is stmt_list, its elements are moved to Program, so $2 itself can be deleted
        // delete $2; // Careful: if *$2 contents are moved, vector shell should be deleted.
    }
    | statement_list {
        root = new Program(SourceLocation(yylineno, @1.first_column), {}, *$1);
        // delete $1; // Careful with $1 contents
    }
    | function_list {
        std::vector<FunctionDeclaration*> funcs;
        for (auto* s : *$1) {
            if (auto* f = dynamic_cast<FunctionDeclaration*>(s)) funcs.push_back(f);
            // else delete s;
        }
        root = new Program(SourceLocation(yylineno, @1.first_column), funcs, {});
        delete $1;
    }
    ;

function_list
    : function_declaration { $$ = new std::vector<Statement*>(); $$->push_back($1); }
    | function_list function_declaration { $$ = $1; $$->push_back($2); }
    ;

function_declaration
    : FUNCTION ID '(' param_list ')' ARROW expression ';' %prec FUNCTION_PREC {
        std::vector<Statement*> statements;
        statements.push_back(new ReturnStatement(SourceLocation(yylineno, @7.first_column), $7)); // loc for expression $7
        $$ = new FunctionDeclaration(
            SourceLocation(yylineno, @1.first_column),
            $2,
            *$4,
            new BlockStatement(SourceLocation(yylineno, @6.first_column), statements) // loc for ARROW
        );
        free($2);
        delete $4;
    }
    | FUNCTION ID '(' param_list ')' '{' statement_list '}' %prec FUNCTION_PREC {
        $$ = new FunctionDeclaration(
            SourceLocation(yylineno, @1.first_column),
            $2,
            *$4,
            new BlockStatement(SourceLocation(yylineno, @6.first_column), *$7)
        );
        free($2);
        delete $4;
        delete $7;
    }
    ;

param_list
    : /* empty */ { $$ = new std::vector<std::string>(); }
    | ID { $$ = new std::vector<std::string>(); $$->push_back($1); free($1); }
    | param_list ',' ID { $$ = $1; $$->push_back($3); free($3); }
    ;

block_expr // This produces an Expression*
    : '{' statement_list '}' {
        $$ = new BlockExpression(SourceLocation(yylineno, @1.first_column), *$2);
        delete $2; // Delete the vector shell, contents moved to BlockExpression
    }
    ;

// block_stmt is now just the body for clarity, used by function_declaration, while_statement etc.
// It produces a std::vector<Statement*>*
block_stmt_body
    : statement_list { $$ = $1; } // Pass ownership of statement_list
    | /* empty block */ { $$ = new std::vector<Statement*>(); }
    ;

statement_list
    : statement { $$ = new std::vector<Statement*>(); $$->push_back($1); }
    | statement_list statement { $$ = $1; $$->push_back($2); }
    ;

statement
    : ID ASSIGN expression ';' { // Assignment is a statement
        $$ = new ExpressionStatement(SourceLocation(yylineno, @1.first_column), 
            new AssignmentExpression(SourceLocation(yylineno, @1.first_column), $1, $3));
        free($1);
    }
    | while_statement
    | expression_statement
    ;

// Simplified expression_statement
expression_statement
    : expression ';' { // Any expression followed by a semicolon is a statement
        $$ = new ExpressionStatement(SourceLocation(yylineno, @1.first_column), $1);
    }
    ;

while_statement
    : WHILE '(' expression ')' '{' block_stmt_body '}' {
        $$ = new WhileStatement(
            SourceLocation(yylineno, @1.first_column), $3,
            new BlockStatement(SourceLocation(yylineno, @5.first_column), *$6)
        );
        delete $6; // $6 is vector shell, contents moved
    }
    ;

// FOR LOOPS: for_loop_expr is the only for construct, it's an expression.
// To use as a statement, it becomes: for_loop_expr ';' (via expression_statement)
for_loop_expr
    : FOR '(' ID IN expression ')' expression { // Body can be any expression
        SourceLocation forLoc = SourceLocation(yylineno, @1.first_column); 
        SourceLocation idLoc = SourceLocation(yylineno, @3.first_column);   
        
        std::string loopVarName = $3; 
        free($3);                     
        std::string iterName = "__iter_" + loopVarName;
        std::string resultVarName = "__result_" + loopVarName;

        // Create the loop structure:
        // let __iter_i = range(...), __result_i = 1 in { // Or some other initial value based on op
        //   while (__iter_i.next()) {
        //     let i = __iter_i.current() in {
        //       __result_i = __result_i <op> i; // e.g., __result_i = __result_i * i;
        //     }
        //   }
        //   __result_i
        // }
        
        // Create the inner let-in that binds the loop variable
        auto getCurrentExpr = new FunctionCall(idLoc, iterName + ".current", {});
        
        // Create result variable and accumulation operation
        auto resultVar = new Variable(idLoc, resultVarName);
        
        // For factorial-style accumulation, we need to multiply the result by the current value
        // This assumes the body of the for loop ($7) is the operation to perform,
        // and the loop variable ($3, now loopVarName) is implicitly used by $7,
        // or $7 is the value to accumulate.
        // The current desugaring seems to assume $7 is an expression that becomes part of an accumulation.
        // Let's assume the for loop `for (i in range) body_expr` means to accumulate `body_expr` values.
        // If `body_expr` is `i` and we want sum, it'd be `__result_i = __result_i + i`.
        // The example `__result_i * i` implies the body_expr ($7) is `i` and op is `*`.
        // The current rule `FOR '(' ID IN expression ')' expression` uses $7 as the expression to be evaluated in each iteration.
        // Let's assume the for loop is meant to be an accumulator, and $7 is the expression whose values are accumulated.
        // The example `__result_i = __result_i * i;` in comments suggests the loop variable `i` is used.
        // If $7 is `i` (Variable(loopVarName)), then `accumExpr` would be `new BinaryOperation(idLoc, resultVar, new Variable(idLoc, loopVarName), "*")`.
        // The current code uses $7 directly: `auto accumExpr = new BinaryOperation(idLoc, resultVar, $7, "*");`
        // This means if you write `for x in 1..3 x*x`, $7 is `x*x`.
        // Then `__result_x = __result_x * (x*x)`. This seems like a specific interpretation (product of squares).
        // For now, I'll keep the existing logic for $7.

        auto accumExpr = new BinaryOperation(idLoc, resultVar, $7, "*"); // Assuming '*' is the desired accumulation op. This should be configurable or based on for loop type.
        auto assignResultStmt = new ExpressionStatement(idLoc, 
            new AssignmentExpression(idLoc, resultVarName, accumExpr));
        
        // Create the inner let-in with the loop variable
        auto letInBody = new BlockExpression(SourceLocation(yylineno, @7.first_column), // loc of $7
            { assignResultStmt });
        auto letInVar = new LetIn(SourceLocation(yylineno, @7.first_column), // loc of $7
            { std::make_pair(loopVarName, getCurrentExpr) }, letInBody);
        
        // Create the while loop body
        auto whileBodyStmt = new BlockStatement(SourceLocation(yylineno, @7.first_column), // loc of $7
            { new ExpressionStatement(SourceLocation(yylineno, @7.first_column), letInVar) }); // loc of $7
        
        // Create the while condition (iterator.next())
        auto getNextExpr = new FunctionCall(forLoc, iterName + ".next", {});
        auto whileStmt = new WhileStatement(forLoc, getNextExpr, whileBodyStmt);
        
        // Create the final block that returns the result
        auto finalResultVar = new Variable(forLoc, resultVarName);
        auto outerLetBody = new BlockExpression(forLoc, 
            { whileStmt, new ExpressionStatement(forLoc, finalResultVar) });
        
        // Initialize result variable. For multiplication, it's 1. For sum, 0.
        // This should depend on the accumulation operation.
        auto oneInit = new Number(forLoc, 1); // Assuming product accumulation
        $$ = new LetIn(forLoc, { 
            std::make_pair(iterName, $5), // $5 is the range expression
            std::make_pair(resultVarName, oneInit)
        }, outerLetBody);
    }
    ;


while_expr
    : WHILE '(' expression ')' block_expr {
        // Cast $5 to BlockExpression* since block_expr should return BlockExpression*
        $$ = new WhileExpression(
            SourceLocation(yylineno, @1.first_column),
            $3,
            static_cast<BlockExpression*>($5)
        );
    }
    | WHILE '(' expression ')' LET binding_list IN expression %prec LET_IN_PREC {
        // Body of LetIn is $8 (expression)
        auto letInExpr = new LetIn(SourceLocation(yylineno, @5.first_column), *$6, $8);
        // Body of WhileExpression needs to be a BlockExpression
        auto letBlock = new BlockExpression(SourceLocation(yylineno, @5.first_column),
            { new ExpressionStatement(SourceLocation(yylineno, @5.first_column), letInExpr) });
        $$ = new WhileExpression(
            SourceLocation(yylineno, @1.first_column),
            $3,
            letBlock
        );
        delete $6;
    }
    ;

expression
    : ID %prec ID                { $$ = new Variable(SourceLocation(yylineno, @1.first_column), $1); free($1); }
    | ID '(' expr_list ')' %prec ID { 
        $$ = new FunctionCall(SourceLocation(yylineno, @1.first_column), $1, *$3); 
        free($1); delete $3; 
    }
    | ID ASSIGN expression       { // Assignment as expression
        $$ = new AssignmentExpression(SourceLocation(yylineno, @1.first_column), $1, $3);
        free($1);
    }
    | let_in_expr
    | if_expr
    | print_expr
    | expression '+' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "+"); }
    | expression '-' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "-"); }
    | expression '*' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "*"); }
    | expression '/' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "/"); }
    | expression '^' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "^"); }
    | expression '%' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "%"); }
    | expression CONCAT expression { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "@"); }
    | expression EQ expression   { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "=="); }
    | expression NEQ expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "!="); }
    | expression '<' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "<"); }
    | expression '>' expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, ">"); }
    | expression LE expression   { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "<="); }
    | expression GE expression   { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, ">="); }
    | expression AND expression  { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "&&"); }
    | expression OR expression   { $$ = new BinaryOperation(SourceLocation(yylineno, @2.first_column), $1, $3, "||"); }
    | NUMBER                     { $$ = new Number(SourceLocation(yylineno, @1.first_column), $1); }
    | STRING                     { $$ = new StringLiteral(SourceLocation(yylineno, @1.first_column), $1); free($1); }
    | '(' expression ')'         { $$ = $2; }
    | block_expr
    | while_expr
    | for_loop_expr // Renamed from for_expr
    ;

// IF Expression structure
// if_expr : IF '(' condition ')' then_expression opt_else_part
// opt_else_part handles:
//   1. No else (lower precedence via %prec IF_PREC)
//   2. ELSE else_expression (higher precedence via %prec ELSE)
//   3. ELIF_LIST ELSE else_expression (higher precedence via %prec ELSE)
if_expr
    : IF '(' expression ')' expression opt_else_part {
        SourceLocation ifLoc = SourceLocation(yylineno, @1.first_column);
        Expression* condExpr = $3;
        Expression* thenExpr = $5;
        ElsePartInfo* elseInfo = $6;

        Expression* finalElseBranch = elseInfo->else_expr;

        if (elseInfo->elifs) { // If there are ELIFs
            // Iterate ELIFs in reverse to build nested IfExpressions for the else chain
            for (auto it = elseInfo->elifs->rbegin(); it != elseInfo->elifs->rend(); ++it) {
                // Each ELIF becomes an IfExpression whose "else" is the next ELIF or final ELSE
                finalElseBranch = new IfExpression(ifLoc, it->first /*elif_cond*/, it->second /*elif_then*/, finalElseBranch);
            }
            delete elseInfo->elifs; // Clean up the elif list vector
        }
        
        // If there was no ELSE keyword at all (e.g. IF cond THEN expr), finalElseBranch would be nullptr from opt_else_part.
        // If there was an ELSE keyword but no ELIFs, finalElseBranch is elseInfo->else_expr.
        // If there were ELIFs, finalElseBranch is the chain of IfExpressions from ELIFs.
        $$ = new IfExpression(ifLoc, condExpr, thenExpr, finalElseBranch);
        delete elseInfo; // Clean up the ElsePartInfo struct
    }
    ;

opt_else_part // Returns ElsePartInfo*
    : %prec IF_PREC { // No ELSE part, IF_PREC gives this lower precedence
        $$ = new ElsePartInfo(nullptr, nullptr, false);
    }
    | ELSE expression %prec ELSE { // Simple ELSE part
        $$ = new ElsePartInfo(nullptr, $2, true);
    }
    | elif_list_non_empty ELSE expression %prec ELSE { // ELIFs then ELSE part
        $$ = new ElsePartInfo($1, $3, true); // $1 is ElifListType* from elif_list_non_empty
    }
    ;

elif_list_non_empty // Produces ElifListType* (must have at least one ELIF)
    : ELIF '(' expression ')' expression {
        $$ = new ElifListType();
        $$->push_back(std::make_pair($3, $5));
        // Need to capture location of ELIF if IfExpression for ELIF needs it.
        // For now, pair only stores cond & then. Location can be approximated from main IF.
    }
    | elif_list_non_empty ELIF '(' expression ')' expression {
        $$ = $1;
        $$->push_back(std::make_pair($4, $6));
    }
    ;

// LET expression structure
// let_in_expr : LET binding_list IN expression
binding_list // Produces std::vector<std::pair<std::string, Expression*>>*
    : ID ASSIGN expression { // A single binding
        $$ = new std::vector<std::pair<std::string, Expression*>>();
        $$->push_back(std::make_pair(std::string($1), $3));
        free($1);
    }
    | binding_list ',' ID ASSIGN expression { // Subsequent bindings in the list
        $$ = $1;
        $$->push_back(std::make_pair(std::string($3), $5));
        free($3);
    }
    ;

expr_list
    : /* empty */ { $$ = new std::vector<Expression*>(); } // Allow empty expr_list for calls like f()
    | expression { $$ = new std::vector<Expression*>(); $$->push_back($1); }
    | expr_list ',' expression { $$ = $1; $$->push_back($3); }
    ;

print_expr
    : PRINT '(' expr_list ')' {
        if ($3->empty()) { // Check if expr_list is empty
             SEMANTIC_ERROR("print requiere al menos un argumento", SourceLocation(yylineno, @1.first_column));
             YYABORT;
        }
        // For simplicity, let's assume Print takes a vector of expressions if multiple args are allowed
        // Or, if Print only takes one arg, ensure $3->size() == 1
        if ($3->size() > 1) {
             SEMANTIC_ERROR("print actualmente solo soporta un argumento", SourceLocation(yylineno, @1.first_column));
             // Decide: YYABORT, or take first, or modify Print node
        }
        $$ = new Print(SourceLocation(yylineno, @1.first_column), (*$3)[0]); // Taking first arg
        
        // Memory management for expr_list ($3)
        for (size_t i = 0; i < $3->size(); ++i) {
            if (i != 0) delete (*$3)[i]; // Delete expressions not taken by Print
        }
        delete $3; // Delete the vector shell
    }
    ;

let_in_expr
    : LET binding_list IN expression %prec LET_IN_PREC {
        $$ = new LetIn(SourceLocation(yylineno, @1.first_column), *$2, $4);
        delete $2; // $2 is binding_list (vector shell), contents moved or copied by LetIn
    }
    ;

%%


